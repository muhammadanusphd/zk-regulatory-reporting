# 🔐 Zero-Knowledge Regulatory Reporting
**zk-SNARK-powered platform for AML/CFT compliance without exposing personal transaction data**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
[![Build](https://github.com/USERNAME/Zero-Knowledge-Regulatory-Reporting/actions/workflows/test.yml/badge.svg)](./.github/workflows/test.yml)
[![Research Project](https://img.shields.io/badge/Research-PhD--Track-blue)](whitepaper/main.tex)
[![Circom](https://img.shields.io/badge/ZK-Circom%202.x-orange)](https://docs.circom.io/)
[![snarkjs](https://img.shields.io/badge/Proof-snarkjs-success)](https://github.com/iden3/snarkjs)

> **Author:** *Muhammad Anus*  
> **Supervisor:** *Prof. Ts. Dr. MD Asri bin Ngadi (Head of Computer Science), Universiti Teknologi Malaysia (UTM)*

---

## 0) TL;DR (60 seconds)

- This repo shows how to **prove AML/CFT compliance** (like “amount ≤ threshold”, “KYC membership”, and “not sanctioned”) **without revealing personal data**.
- We do this using **zero-knowledge proofs (zk-SNARKs)** with a **Circom circuit** and **snarkjs**.
- There is a **CLI** to generate & verify proofs and a **Solidity contract** to log on-chain **compliance attestations**.
- You can run everything locally with a few commands:
  ```bash
  npm install
  npm run setup:ptau
  npm run build:circuits
  npm run prove
  npm run verify
1) Plain-English Problem & Idea

Problem: Regulators require AML/CFT checks (is the user KYC’d? is the transaction under a limit? not on a sanctions list?). Today that usually means revealing lots of private data.

Idea: Use zero-knowledge proofs:

The institution proves “I’m compliant” to the regulator without revealing the raw data.

The regulator checks just a proof and a few public values (like a root hash), not the personal information.

What this repo proves (demo):

Amount ≤ AML threshold (e.g., ≤ 10,000)

User is in the KYC tree (Merkle inclusion proof)

User is not sanctioned (toy example bit; roadmap explains better sets/accumulators)

Transaction commitment is consistent with the private inputs (binds proof to the tx)

2) How the Demo Flows (End-to-End)

You set up the trusted setup files (Powers of Tau, small demo).

You compile the Circom circuit and create proving/verifying keys (Groth16).

The CLI generates synthetic private data (demo values) and builds a Poseidon-based Merkle tree for KYC.

The CLI computes a witness and then a zk-SNARK proof (using snarkjs).

You verify the proof locally or on-chain using the generated verifier contract + our RegCompliance contract.

3) Repository Structure (What each folder/file is)
Zero-Knowledge-Regulatory-Reporting/
│── README.md                      # ← you’re reading this
│── LICENSE                        # MIT license
│── CITATION.cff                   # academic citation metadata
│── CONTRIBUTING.md                # how to contribute
│── CODE_OF_CONDUCT.md             # community rules
│── package.json                   # npm project definition
│── package-lock.json              # (recommended) dependency lock
│── .eslintrc.json                 # lint rules (optional)
│── .prettierrc                    # formatting rules (optional)
│── .gitignore                     # ignore build artifacts, etc.
│
├── scripts/
│   ├── setup-ptau.js              # generates Powers of Tau (phase 1/2) for demo
│   └── build-circuits.js          # compiles circuit + Groth16 setup + Solidity verifier
│
├── src/
│   ├── circuits/
│   │   └── aml_verifier.circom    # the zk circuit (amount ≤ threshold, KYC inclusion, not sanctioned)
│   ├── cli/
│   │   ├── proofgen.js            # generates witness + proof + public signals
│   │   └── verify.js              # verifies proof locally
│   └── contracts/
│       ├── Verifier.sol           # auto-generated by snarkjs (after build)
│       └── RegCompliance.sol      # logs compliance attestations
│
├── tests/
│   └── proof.test.js              # CI test: build → prove → verify
│
├── docs/
│   ├── ARCHITECTURE.md            # deep-dive explanation
│   ├── ROADMAP.md                 # research milestones
│   ├── PRIVACY.md                 # privacy principles
│   └── SECURITY.md                # security notes & limitations
│
└── whitepaper/
    ├── main.tex                   # LaTeX whitepaper
    └── Makefile                   # build to PDF (optional)


If you’re showing this to a scholarship committee, point them to:

README.md (this file) for the story + steps

src/circuits/aml_verifier.circom for the actual ZK logic

src/contracts/RegCompliance.sol for the on-chain angle

whitepaper/main.tex for the academic framing

4) Prerequisites

Node.js 18+ (Node 20 recommended), npm 9+

Git (optional but recommended)

Circom compiler (two options):

Option A (recommended): install Circom binary from source (Rust toolchain required)

# Install Rust (if not installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build circom from source
git clone https://github.com/iden3/circom.git
cd circom
cargo build --release
sudo cp target/release/circom /usr/local/bin/circom
circom --version


Option B: download a prebuilt binary from the Circom releases page (place it on your PATH as circom)

Note: Our scripts call npx circom .... That works if a compatible circom CLI is available in your environment. If npx circom doesn’t work, use circom directly and adjust commands accordingly.

5) Quickstart: Run the Demo (Step-by-Step)
Step 5.1 – Install dependencies
npm install


This will also create package-lock.json (useful for CI).

Step 5.2 – Generate Powers of Tau (trusted setup for demo)
npm run setup:ptau


Produces build/ptau/pot12_final.ptau (small demo size; not production).

Step 5.3 – Compile the Circom circuit + Groth16 setup
npm run build:circuits


This will:

Compile src/circuits/aml_verifier.circom → build/circuits/aml_verifier.r1cs + .wasm

Run Groth16 setup & contribution → aml_verifier_final.zkey

Export verification key → verification_key.json

Generate Solidity verifier → src/contracts/Verifier.sol

Step 5.4 – Generate a proof (with synthetic demo data)
npm run prove


This:

Creates a toy KYC Poseidon Merkle tree

Picks a demo leaf for you (pretend this is the user’s KYC commitment)

Sets amount = 2500 and threshold = 10000

Builds a witness, then outputs:

build/circuits/proof.json

build/circuits/public.json (public signals)

Step 5.5 – Verify the proof locally
npm run verify


You should see: ✅ Verification OK

If it fails, jump to Section 11: Troubleshooting.

6) What Exactly Are We Proving?

The circuit enforces four things:

Amount ≤ Threshold
A custom comparator checks the private amount is less than or equal to the public threshold.

KYC Membership
The prover knows a private preimage (attributes) that hash to a leaf in a Poseidon Merkle tree whose root is public.

This shows “user is KYC’d” without revealing the attributes.

Not Sanctioned (toy model for demo)
We witness a private bit isSanctioned = 0.

In real systems, we’d use non-membership proofs with accumulators or a well-designed set-membership scheme.

The README and ROADMAP call out this limitation honestly (interview-worthy honesty).

Tx Commitment Consistency
We bind pub_tx_commitment = Poseidon(amount, nonce) so the proof connects to a transaction without revealing amount or the nonce.

Public Inputs (verifier sees):

[ threshold, kycRoot, sanctionsRoot, txCommitment ]


Private Inputs (kept secret):

amount, user attributes (two field elements), nonce,
Merkle path and pathIndex, isSanctioned bit

7) Understand the Files That Do the Work
7.1 Circuit: src/circuits/aml_verifier.circom

LessEq64 → compares 64-bit values inside the circuit

MerkleInclusion → Poseidon-based inclusion proof

SanctionsBit → toy “non-sanctioned” predicate

AMLVerifier (main) → wires it all together

7.2 CLI: src/cli/proofgen.js

Generates synthetic inputs (safe demo)

Builds a Merkle tree in JS (Poseidon)

Calculates the witness, proof, and public signals via snarkjs

7.3 Local Verification: src/cli/verify.js

Calls snarkjs groth16 verify on your outputs

7.4 Contracts

src/contracts/Verifier.sol (auto-generated) verifies Groth16 proofs

src/contracts/RegCompliance.sol stores attestations on-chain with an event

8) (Optional) On-Chain Demo with Hardhat

This is optional but looks great in a research portfolio.

Step 8.1 – Compile contracts
npm run compile

Step 8.2 – Create a deploy script (if not present)

Create scripts/deploy.js with:

import { ethers } from "hardhat";

async function main() {
  const Verifier = await ethers.getContractFactory("Verifier");
  const verifier = await Verifier.deploy();
  await verifier.waitForDeployment();
  console.log("Verifier deployed:", await verifier.getAddress());

  const RegCompliance = await ethers.getContractFactory("RegCompliance");
  const reg = await RegCompliance.deploy(await verifier.getAddress());
  await reg.waitForDeployment();
  console.log("RegCompliance deployed:", await reg.getAddress());
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

Step 8.3 – Run a local node and deploy
# Terminal 1
npx hardhat node

# Terminal 2
npx hardhat run scripts/deploy.js --network localhost


You’ll see two addresses printed (Verifier + RegCompliance).

To push to a testnet (e.g., Sepolia), set SEPOLIA_RPC and PRIVATE_KEY in a .env file and run:

npx hardhat run scripts/deploy.js --network sepolia

9) How to Customize the Demo (change inputs)

Open src/cli/proofgen.js:

Change threshold: set const threshold = 10_000n;

Change amount: set const amount = 2500n;

Change user attributes: attr1, attr2 (two field elements)

Pick a different leaf index: change leaves[3] = myLeaf; and the path builder index

Then re-run:

npm run prove
npm run verify

10) Research Notes

Why ZK for AML/CFT?
Because it reduces data exposure while keeping verifiability. Regulators see proofs instead of raw PII.

What’s proven?
Compliance predicates (thresholds, memberships, non-sanctioned) with public inputs (roots/thresholds) and private inputs (amount, attributes, paths).

Trusted setup & Groth16:
Our demo uses Groth16 (small proofs, fast verify) but needs a trusted setup.
Future: move to Plonk/Halo2 (universal setup) and recursive proofs (batching many tx proofs).

Sanctions set:
The demo uses a bit for simplicity. For real systems, use:

Dynamic accumulators (e.g., RSA Accumulators) or

Merkle non-membership / membership with updatable roots.

Privacy & governance:
Roots should be published by audited parties. KYC providers update roots; regulators observe roots and accept proofs against those roots.

11) Troubleshooting (Common Errors & Fixes)
Symptom / Error	Why it happens	Quick Fix
circom: command not found	Circom CLI not installed or not on PATH	Install via Rust build or prebuilt release, ensure circom --version works
spawn circom ENOENT or npx circom fails	GitHub Action runner / local env lacks circom	Install circom, or replace npx circom with direct circom in scripts
CI says “Dependencies lock file is not found”	No package-lock.json	Run npm install locally, commit package-lock.json, or set cache-dependency-path: package.json in workflow
Can’t create .prettierrc on GitHub UI	Dotfiles sometimes blocked in basic UI	Use local git, or “Create new file” and name exactly .prettierrc
Error: invalid proof on verify	Public inputs changed / wrong zkey	Re-run npm run build:circuits and then npm run prove again
Out of memory in circuit build	Low RAM build	Close apps, try smaller tree depth, or build on a machine with ≥ 8 GB RAM
Hardhat deploy fails (no accounts)	Network not configured	For localhost, start npx hardhat node; for testnet, set .env with RPC + PRIVATE_KEY
Node version mismatch	Older Node/npm	Use Node 20+; nvm install 20 && nvm use 20
12) CI (GitHub Actions)

This repo ships with .github/workflows/test.yml which:

Installs Node

Runs npm ci

Runs npm run setup:ptau

Builds circuits

Runs tests

Tip: Commit a package-lock.json to enable dependency caching and stable builds.
Tip: If circom isn’t present on runners, add a step to install circom or run CI without circuit compilation.

13) Security, Privacy, and Limitations

Research prototype: Do not use for real regulatory filings.

Groth16 trusted setup: A compromised setup can break soundness—run a proper multi-party ceremony if you go beyond demo.

Sanctions proof: Current demo uses a simple bit. Replace with proper set (non-)membership in future versions.

Key/roots freshness: Regulators must ensure fresh roots (KYC & sanctions) and verify publication/rotation policies.

See docs/SECURITY.md and docs/PRIVACY.md for more detail.

14) Roadmap (Where this goes next)

v2: On-chain verifier flow with events, read-only regulator dashboard

v3: Proper sanctions set with accumulators; Merkle non-membership

v4: Halo2/Plonk migration (universal setup), recursive proofs

v5: Multiple predicates (velocity checks, structuring patterns), performance evaluation, formal threat model, datasets

(Details in docs/ROADMAP.md.)

15) Whitepaper (Academic Artifact)

LaTeX source: whitepaper/main.tex

Build PDF:

cd whitepaper
make
# output: whitepaper/build/paper.pdf


Cite this work:

@misc{Anus2025ZKReporting,
  author       = {Muhammad Anus},
  title        = {Zero-Knowledge Regulatory Reporting: zk-SNARK-Powered Platform for AML/CFT Compliance},
  year         = {2025},
  publisher    = {GitHub},
  howpublished = {\url{https://github.com/USERNAME/Zero-Knowledge-Regulatory-Reporting}}
}
