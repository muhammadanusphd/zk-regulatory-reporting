# üîê Zero-Knowledge Regulatory Reporting
**zk-SNARK-powered platform for AML/CFT compliance without exposing personal transaction data**

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)
[![Build](https://github.com/USERNAME/Zero-Knowledge-Regulatory-Reporting/actions/workflows/test.yml/badge.svg)](./.github/workflows/test.yml)
[![Research Project](https://img.shields.io/badge/Research-PhD--Track-blue)](whitepaper/main.tex)
[![Circom](https://img.shields.io/badge/ZK-Circom%202.x-orange)](https://docs.circom.io/)
[![snarkjs](https://img.shields.io/badge/Proof-snarkjs-success)](https://github.com/iden3/snarkjs)

> **Author:** *Muhammad Anus*  
> **Supervisor:** *Prof. Ts. Dr. MD Asri bin Ngadi (Head of Computer Science), Universiti Teknologi Malaysia (UTM)*

---

## 0) TL;DR (60 seconds)

- This repo shows how to **prove AML/CFT compliance** (like ‚Äúamount ‚â§ threshold‚Äù, ‚ÄúKYC membership‚Äù, and ‚Äúnot sanctioned‚Äù) **without revealing personal data**.
- We do this using **zero-knowledge proofs (zk-SNARKs)** with a **Circom circuit** and **snarkjs**.
- There is a **CLI** to generate & verify proofs and a **Solidity contract** to log on-chain **compliance attestations**.
- You can run everything locally with a few commands:
  ```bash
  npm install
  npm run setup:ptau
  npm run build:circuits
  npm run prove
  npm run verify
1) Plain-English Problem & Idea

Problem: Regulators require AML/CFT checks (is the user KYC‚Äôd? is the transaction under a limit? not on a sanctions list?). Today that usually means revealing lots of private data.

Idea: Use zero-knowledge proofs:

The institution proves ‚ÄúI‚Äôm compliant‚Äù to the regulator without revealing the raw data.

The regulator checks just a proof and a few public values (like a root hash), not the personal information.

What this repo proves (demo):

Amount ‚â§ AML threshold (e.g., ‚â§ 10,000)

User is in the KYC tree (Merkle inclusion proof)

User is not sanctioned (toy example bit; roadmap explains better sets/accumulators)

Transaction commitment is consistent with the private inputs (binds proof to the tx)

2) How the Demo Flows (End-to-End)

You set up the trusted setup files (Powers of Tau, small demo).

You compile the Circom circuit and create proving/verifying keys (Groth16).

The CLI generates synthetic private data (demo values) and builds a Poseidon-based Merkle tree for KYC.

The CLI computes a witness and then a zk-SNARK proof (using snarkjs).

You verify the proof locally or on-chain using the generated verifier contract + our RegCompliance contract.

3) Repository Structure (What each folder/file is)
Zero-Knowledge-Regulatory-Reporting/
‚îÇ‚îÄ‚îÄ README.md                      # ‚Üê you‚Äôre reading this
‚îÇ‚îÄ‚îÄ LICENSE                        # MIT license
‚îÇ‚îÄ‚îÄ CITATION.cff                   # academic citation metadata
‚îÇ‚îÄ‚îÄ CONTRIBUTING.md                # how to contribute
‚îÇ‚îÄ‚îÄ CODE_OF_CONDUCT.md             # community rules
‚îÇ‚îÄ‚îÄ package.json                   # npm project definition
‚îÇ‚îÄ‚îÄ package-lock.json              # (recommended) dependency lock
‚îÇ‚îÄ‚îÄ .eslintrc.json                 # lint rules (optional)
‚îÇ‚îÄ‚îÄ .prettierrc                    # formatting rules (optional)
‚îÇ‚îÄ‚îÄ .gitignore                     # ignore build artifacts, etc.
‚îÇ
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ setup-ptau.js              # generates Powers of Tau (phase 1/2) for demo
‚îÇ   ‚îî‚îÄ‚îÄ build-circuits.js          # compiles circuit + Groth16 setup + Solidity verifier
‚îÇ
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ circuits/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ aml_verifier.circom    # the zk circuit (amount ‚â§ threshold, KYC inclusion, not sanctioned)
‚îÇ   ‚îú‚îÄ‚îÄ cli/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ proofgen.js            # generates witness + proof + public signals
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ verify.js              # verifies proof locally
‚îÇ   ‚îî‚îÄ‚îÄ contracts/
‚îÇ       ‚îú‚îÄ‚îÄ Verifier.sol           # auto-generated by snarkjs (after build)
‚îÇ       ‚îî‚îÄ‚îÄ RegCompliance.sol      # logs compliance attestations
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ proof.test.js              # CI test: build ‚Üí prove ‚Üí verify
‚îÇ
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ ARCHITECTURE.md            # deep-dive explanation
‚îÇ   ‚îú‚îÄ‚îÄ ROADMAP.md                 # research milestones
‚îÇ   ‚îú‚îÄ‚îÄ PRIVACY.md                 # privacy principles
‚îÇ   ‚îî‚îÄ‚îÄ SECURITY.md                # security notes & limitations
‚îÇ
‚îî‚îÄ‚îÄ whitepaper/
    ‚îú‚îÄ‚îÄ main.tex                   # LaTeX whitepaper
    ‚îî‚îÄ‚îÄ Makefile                   # build to PDF (optional)


If you‚Äôre showing this to a scholarship committee, point them to:

README.md (this file) for the story + steps

src/circuits/aml_verifier.circom for the actual ZK logic

src/contracts/RegCompliance.sol for the on-chain angle

whitepaper/main.tex for the academic framing

4) Prerequisites

Node.js 18+ (Node 20 recommended), npm 9+

Git (optional but recommended)

Circom compiler (two options):

Option A (recommended): install Circom binary from source (Rust toolchain required)

# Install Rust (if not installed)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Build circom from source
git clone https://github.com/iden3/circom.git
cd circom
cargo build --release
sudo cp target/release/circom /usr/local/bin/circom
circom --version


Option B: download a prebuilt binary from the Circom releases page (place it on your PATH as circom)

Note: Our scripts call npx circom .... That works if a compatible circom CLI is available in your environment. If npx circom doesn‚Äôt work, use circom directly and adjust commands accordingly.

5) Quickstart: Run the Demo (Step-by-Step)
Step 5.1 ‚Äì Install dependencies
npm install


This will also create package-lock.json (useful for CI).

Step 5.2 ‚Äì Generate Powers of Tau (trusted setup for demo)
npm run setup:ptau


Produces build/ptau/pot12_final.ptau (small demo size; not production).

Step 5.3 ‚Äì Compile the Circom circuit + Groth16 setup
npm run build:circuits


This will:

Compile src/circuits/aml_verifier.circom ‚Üí build/circuits/aml_verifier.r1cs + .wasm

Run Groth16 setup & contribution ‚Üí aml_verifier_final.zkey

Export verification key ‚Üí verification_key.json

Generate Solidity verifier ‚Üí src/contracts/Verifier.sol

Step 5.4 ‚Äì Generate a proof (with synthetic demo data)
npm run prove


This:

Creates a toy KYC Poseidon Merkle tree

Picks a demo leaf for you (pretend this is the user‚Äôs KYC commitment)

Sets amount = 2500 and threshold = 10000

Builds a witness, then outputs:

build/circuits/proof.json

build/circuits/public.json (public signals)

Step 5.5 ‚Äì Verify the proof locally
npm run verify


You should see: ‚úÖ Verification OK

If it fails, jump to Section 11: Troubleshooting.

6) What Exactly Are We Proving?

The circuit enforces four things:

Amount ‚â§ Threshold
A custom comparator checks the private amount is less than or equal to the public threshold.

KYC Membership
The prover knows a private preimage (attributes) that hash to a leaf in a Poseidon Merkle tree whose root is public.

This shows ‚Äúuser is KYC‚Äôd‚Äù without revealing the attributes.

Not Sanctioned (toy model for demo)
We witness a private bit isSanctioned = 0.

In real systems, we‚Äôd use non-membership proofs with accumulators or a well-designed set-membership scheme.

The README and ROADMAP call out this limitation honestly (interview-worthy honesty).

Tx Commitment Consistency
We bind pub_tx_commitment = Poseidon(amount, nonce) so the proof connects to a transaction without revealing amount or the nonce.

Public Inputs (verifier sees):

[ threshold, kycRoot, sanctionsRoot, txCommitment ]


Private Inputs (kept secret):

amount, user attributes (two field elements), nonce,
Merkle path and pathIndex, isSanctioned bit

7) Understand the Files That Do the Work
7.1 Circuit: src/circuits/aml_verifier.circom

LessEq64 ‚Üí compares 64-bit values inside the circuit

MerkleInclusion ‚Üí Poseidon-based inclusion proof

SanctionsBit ‚Üí toy ‚Äúnon-sanctioned‚Äù predicate

AMLVerifier (main) ‚Üí wires it all together

7.2 CLI: src/cli/proofgen.js

Generates synthetic inputs (safe demo)

Builds a Merkle tree in JS (Poseidon)

Calculates the witness, proof, and public signals via snarkjs

7.3 Local Verification: src/cli/verify.js

Calls snarkjs groth16 verify on your outputs

7.4 Contracts

src/contracts/Verifier.sol (auto-generated) verifies Groth16 proofs

src/contracts/RegCompliance.sol stores attestations on-chain with an event

8) (Optional) On-Chain Demo with Hardhat

This is optional but looks great in a research portfolio.

Step 8.1 ‚Äì Compile contracts
npm run compile

Step 8.2 ‚Äì Create a deploy script (if not present)

Create scripts/deploy.js with:

import { ethers } from "hardhat";

async function main() {
  const Verifier = await ethers.getContractFactory("Verifier");
  const verifier = await Verifier.deploy();
  await verifier.waitForDeployment();
  console.log("Verifier deployed:", await verifier.getAddress());

  const RegCompliance = await ethers.getContractFactory("RegCompliance");
  const reg = await RegCompliance.deploy(await verifier.getAddress());
  await reg.waitForDeployment();
  console.log("RegCompliance deployed:", await reg.getAddress());
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});

Step 8.3 ‚Äì Run a local node and deploy
# Terminal 1
npx hardhat node

# Terminal 2
npx hardhat run scripts/deploy.js --network localhost


You‚Äôll see two addresses printed (Verifier + RegCompliance).

To push to a testnet (e.g., Sepolia), set SEPOLIA_RPC and PRIVATE_KEY in a .env file and run:

npx hardhat run scripts/deploy.js --network sepolia

9) How to Customize the Demo (change inputs)

Open src/cli/proofgen.js:

Change threshold: set const threshold = 10_000n;

Change amount: set const amount = 2500n;

Change user attributes: attr1, attr2 (two field elements)

Pick a different leaf index: change leaves[3] = myLeaf; and the path builder index

Then re-run:

npm run prove
npm run verify

10) Research Notes

Why ZK for AML/CFT?
Because it reduces data exposure while keeping verifiability. Regulators see proofs instead of raw PII.

What‚Äôs proven?
Compliance predicates (thresholds, memberships, non-sanctioned) with public inputs (roots/thresholds) and private inputs (amount, attributes, paths).

Trusted setup & Groth16:
Our demo uses Groth16 (small proofs, fast verify) but needs a trusted setup.
Future: move to Plonk/Halo2 (universal setup) and recursive proofs (batching many tx proofs).

Sanctions set:
The demo uses a bit for simplicity. For real systems, use:

Dynamic accumulators (e.g., RSA Accumulators) or

Merkle non-membership / membership with updatable roots.

Privacy & governance:
Roots should be published by audited parties. KYC providers update roots; regulators observe roots and accept proofs against those roots.

11) Troubleshooting (Common Errors & Fixes)
Symptom / Error	Why it happens	Quick Fix
circom: command not found	Circom CLI not installed or not on PATH	Install via Rust build or prebuilt release, ensure circom --version works
spawn circom ENOENT or npx circom fails	GitHub Action runner / local env lacks circom	Install circom, or replace npx circom with direct circom in scripts
CI says ‚ÄúDependencies lock file is not found‚Äù	No package-lock.json	Run npm install locally, commit package-lock.json, or set cache-dependency-path: package.json in workflow
Can‚Äôt create .prettierrc on GitHub UI	Dotfiles sometimes blocked in basic UI	Use local git, or ‚ÄúCreate new file‚Äù and name exactly .prettierrc
Error: invalid proof on verify	Public inputs changed / wrong zkey	Re-run npm run build:circuits and then npm run prove again
Out of memory in circuit build	Low RAM build	Close apps, try smaller tree depth, or build on a machine with ‚â• 8 GB RAM
Hardhat deploy fails (no accounts)	Network not configured	For localhost, start npx hardhat node; for testnet, set .env with RPC + PRIVATE_KEY
Node version mismatch	Older Node/npm	Use Node 20+; nvm install 20 && nvm use 20
12) CI (GitHub Actions)

This repo ships with .github/workflows/test.yml which:

Installs Node

Runs npm ci

Runs npm run setup:ptau

Builds circuits

Runs tests

Tip: Commit a package-lock.json to enable dependency caching and stable builds.
Tip: If circom isn‚Äôt present on runners, add a step to install circom or run CI without circuit compilation.

13) Security, Privacy, and Limitations

Research prototype: Do not use for real regulatory filings.

Groth16 trusted setup: A compromised setup can break soundness‚Äîrun a proper multi-party ceremony if you go beyond demo.

Sanctions proof: Current demo uses a simple bit. Replace with proper set (non-)membership in future versions.

Key/roots freshness: Regulators must ensure fresh roots (KYC & sanctions) and verify publication/rotation policies.

See docs/SECURITY.md and docs/PRIVACY.md for more detail.

14) Roadmap (Where this goes next)

v2: On-chain verifier flow with events, read-only regulator dashboard

v3: Proper sanctions set with accumulators; Merkle non-membership

v4: Halo2/Plonk migration (universal setup), recursive proofs

v5: Multiple predicates (velocity checks, structuring patterns), performance evaluation, formal threat model, datasets

(Details in docs/ROADMAP.md.)

15) Whitepaper (Academic Artifact)

LaTeX source: whitepaper/main.tex

Build PDF:

cd whitepaper
make
# output: whitepaper/build/paper.pdf


Cite this work:

@misc{Anus2025ZKReporting,
  author       = {Muhammad Anus},
  title        = {Zero-Knowledge Regulatory Reporting: zk-SNARK-Powered Platform for AML/CFT Compliance},
  year         = {2025},
  publisher    = {GitHub},
  howpublished = {\url{https://github.com/USERNAME/Zero-Knowledge-Regulatory-Reporting}}
}
